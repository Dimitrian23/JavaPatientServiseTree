# JavaPatient


## Структура проекта

Проект JavaPatient разбивается на три основных пакета, каждый из которых отвечает за определенную функциональность:

### 1. model
Пакет `model` содержит все данные и логику работы с ними. Он разделен на несколько подпакетов:

- **entity**: Содержит класс `Patient`, который представляет данные о пациенте.
- **comparators**: Содержит компараторы для сортировки пациентов по различным критериям: `PatientComparatorByAge`, `PatientComparatorByName`, `PatientComparatorByTime`.
- **operations**: Содержит классы для управления списком пациентов:
  - **iterators**: Содержит `PatientIterator` для итерации по списку пациентов.
  - `PatientListManager`: Управление списком пациентов, включая добавление и сортировку.
  - `PatientMethod`: Интерфейс для методов, которые могут выполняться над пациентами.
- **service**: Содержит сервисный класс `Service`, который обеспечивает бизнес-логику.

### 2. presenter
Пакет `presenter` отвечает за взаимодействие между моделью и представлением. В нем находится класс `Presenter`, который управляет обновлением представления в соответствии с изменениями в модели.

### 3. view
Пакет `view` содержит все классы, связанные с пользовательским интерфейсом:

- **commands**: Содержит команды, которые могут выполняться пользователем: `AddPatient`, `Command`, `Finish`, `GetPatientInfo`, `SortByAge`, `SortByName`, `SortByTime`.
- `ConsoleUI`: Класс, отвечающий за взаимодействие с пользователем через консоль.
- `MainMenu`: Класс, представляющий главное меню приложения.
- `View`: Главный класс представления, который управляет всеми элементами пользовательского интерфейса.

## Принципы SOLID

Проект JavaPatient строго следует принципам SOLID:

- **S**ingle Responsibility Principle (Принцип единственной ответственности): Каждый класс имеет только одну обязанность.
- **O**pen/Closed Principle (Принцип открытости/закрытости): Модули могут быть легко расширены, но не изменены.
- **L**iskov Substitution Principle (Принцип подстановки Барбары Лисков): Подклассы могут использоваться вместо своих суперклассов без изменения их функциональности.
- **I**nterface Segregation Principle (Принцип разделения интерфейса): Клиенты не должны зависеть от интерфейсов, которые они не используют.
- **D**ependency Inversion Principle (Принцип инверсии зависимостей): Высокоуровневые модули не должны зависеть от низкоуровневых; оба должны зависеть от абстракций.



Это разделение обеспечивает чистую архитектуру, где каждый компонент имеет четкую роль и может быть легко изменен или тестирован независимо от других компонентов.



